## Golang细节梳理

熟话说，“工欲善其事，必先利其器”。接触Golang也近一年半，多次想梳理一下，都半途而废，这次趁着空闲，刚好可以一一记录下来。

内容多摘自《Go语言学习笔记》，或他人博文，或官方文档。形式为概括与代码结合，阐述也多以代码注释出现。

本篇文档概括至Go最新发布版，且不定更新。主要分三个方面：一是语言特性，如“类型、表达式、函数、数据、方法、接口”等；
二是编程技巧与理念，如“缓存池、用通信实现数据共享”；三是个人理解，如“对开源项目解构”。

目录：

1. 类型
2. 常量与变量




### 类型

类型包含基础类型与引用类型，基础类型包含“int、float”等等，引用类型包含“slice、map、channel”三种类型。

（1）基础类型：

- 1字节的：bool、byte、int8、uint8
- 2字节的：int16、uint16
- 4字节的：int32、uint32、rune、float32
- 8字节的：int64、uint64、float64、complex64
- 16个字节的：complex128

跟32位、64位平台相关的有：

- 4或8字节：int、uint、uintptr

额外的基础类型还有：string、array、struct、function、interface。

（2）引用类型：

- slice
- map
- channel

引用类型有两个特点：

1. 作为参数作为返回值时，不发生内存拷贝。因此基础类型array是被发生拷贝的，大数组作为参数应该转换为slice。
2. 使用前应用make进行初始化，用new只会分配返回的指针的内存。如map就不会分配其附加属性count等，也不会正确初始化。


（3）类型转换与别名

golang中必须显式类型转换，不同于C/C++。
但是如果是别名的话，因为本身就是同一种类型，因为可以直接赋值。
1.9版本更是增加了定义别名特性。

内置的别名有：

- type byte = uint8
- type rune = uint32

类型转换中容易造成歧义，需要使用括号消除歧义，或使阅读更加清晰。如：

```
(*int)(p) 转换为指针。但*int(p) 即为*(int(p))，意为取地址p处的值，这种用法在操作系统管理内存时多用。
```

（4）自定义类型

- type color uint8

自定义类型不是别名。它是从现有的类型定义出一个新的类型，它们已是两种类型，只是拥有相同的底层数据结构。
其区别有以下几点：

- 不拥有原类型的“method set”，即不实现原类型已实现的接口
- 同原类型必须显式转换
- 同原类型不能直接比较

（5）未命名类型

array、slice、map、channel因为与其元素具体类型或长度有关，所以不能给出唯一的名称，固成为未命名类型。

像数组\[2\]int即是，但我们也可以给他取一个名称。

```
type data [2]int
```

未命名类型转换为有名类型的规则如下：

- 所属的类型相同
- 基础类型相同，其中一个是未命名类型。
- 数据类型相同，将双向通道赋值给单向通道，其中一个为未命名类型。
- 将nil赋值给slice、map、channel、指针、函数或接口。
- 将对象赋值给接口变量，只要对象实现了该接口。


（6）默认值

当申明一个变量时，系统都被默认初始化，以确保不会发生异常。这不同于C的局部变量。

其总结如下：

- false：bool
- 0：int族、uintptr
- 0.0：float族
- 空字符串""：string
- nil：function、interface、slice、map、channel

array、struct根据其元素不同而对应赋予默认值。

（7）类型推断

类型推断就是不用申明具体的类型，而根据被赋予的值推断类型。
所以我们在使用类型推断时，应该清楚的知道当前被赋予什么类型。


```
var1 := 0
var2 := 0.0
// var3 := 0xffffffffffffffff //constant 18446744073709551615 overflows int
var4 := 'c'
var5 := '我'
fmt.Printf("0: %T\n", var1)
fmt.Printf("0.0: %T\n", var2)
// fmt.Printf("0xffffffffffffffff: %T\n", var3)
fmt.Printf("c: %T\n", var4)
fmt.Printf("我: %T\n", var5)

//output:
0: int
0.0: float64
c: int32
我: int32
```

可以看出整数是推断出int，浮点数是推断出float64，字符是推断出int32，如果超出其范围，在编译时就会报错。




### 常量与变量

（1）常量

常量固不能改变的数据。其值必须是编译时期可以确定的字符、字符串、数字或布尔值。

其有以下几个特定：

- 其值必须是字符、字符串、数字、布尔值
- 支持类型推断

在申明时，可以使用常量组，如果不指定类型和初始值，则与上一行非空常量右值表达式文本相同。
这里提到表达式文本，主要是针对iota而言的，因为处于不同行的iota的值是不相同的。

常量的值也可以是编译时期可以确定的表达式，其例子如下：
```
const (
    ptrSize = unsafe.Sizeof(uintptr(0))
    strSize = len("string")
    sliceCap = cap(sliceA)
)
```

- 常量也可以在不同作用域定义同名的常量而不会冲突。


（2）枚举

在Golang中没有内置枚举类型，但是我们一般是通过常量配合iota实现的。

iota有如下几个特点：

- 作用于常量组，不同常量组的iota的初始值都是0
- 常量组每增加一行，不管是否包含iota，iota的值都自增1
- 处于同一行的iota，其值也是相同的
- iota的默认类型的int，也可显示指定为其他类型，如float32等

（3）变量

变量使用var关键字定义，如果未给初始值系统会初始化为默认值。

变量支持简短模式，即使用操作符“:=”，其有以下三个限制：

- 定义变量需要同时显示初始化
- 不能申明其数据类型
- 只能用在函数内部，即不能作用于全局变量

变量支持退化赋值，其条件为：至少有一个新变量被定义，新变量须与旧变量处于统一作用域。

局部变量未使用会在编译时报错。但全局变量和常量不会有这个问题。

（4）多变量赋值

赋值时先从左至右依次计算右值，然后再依次赋值给左边的变量。

如下面这种情况：

```
func inc(x *int, name string) int {
        fmt.Printf("%s: %d\n", name, *x)
        *x++
        return *x
}

func main() {
        x, y := 1, 3
        x, y = inc(&y, "y"), inc(&x, "x")
        fmt.Printf("x=%d, y=%d\n", x, y)
}

// output:
y: 3
x: 1
x=4, y=2
```

（5）空标识符“________”

空标识符多用在接收多返回值时，忽略其中几个返回值。当然忽略error不是一个好习惯。

另一个常用的地方是检测某类型是否实现目标接口。如：

```
var _ InterfaceA = new(StructA)
```
