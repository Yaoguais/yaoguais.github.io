## Golang细节梳理

熟话说，“工欲善其事，必先利其器”。接触Golang也近一年半，多次想梳理一下，都半途而废，这次趁着空闲，刚好可以一一记录下来。

内容多摘自《Go语言学习笔记》，或他人博文，或官方文档。形式为概括与代码结合，阐述也多以代码注释出现。

本篇文档概括至Go最新发布版，且不定更新。主要分三个方面：一是语言特性，如“类型、表达式、函数、数据、方法、接口”等；
二是编程技巧与理念，如“缓存池、用通信实现数据共享”；三是个人理解，如“对开源项目解构”。

目录：

1. 类型




### 类型

类型包含基础类型与引用类型，基础类型包含“int、float”等等，引用类型包含“slice、map、channel”三种类型。

（1）基础类型：

- 1字节的：bool、byte、int8、uint8
- 2字节的：int16、uint16
- 4字节的：int32、uint32、rune、float32
- 8字节的：int64、uint64、float64、complex64
- 16个字节的：complex128

跟32位、64位平台相关的有：

- 4或8字节：int、uint、uintptr

额外的基础类型还有：string、array、struct、function、interface。

（2）引用类型：

- slice
- map
- channel

引用类型有两个特点：

1. 作为参数作为返回值时，不发生内存拷贝。因此基础类型array是被发生拷贝的，大数组作为参数应该转换为slice。
2. 使用前应用make进行初始化，用new只会分配返回的指针的内存。如map就不会分配其附加属性count等，也不会正确初始化。


（3）类型转换与别名

golang中必须显式类型转换，不同于C/C++。
但是如果是别名的话，因为本身就是同一种类型，因为可以直接赋值。
1.9版本更是增加了定义别名特性。

内置的别名有：

- type byte = uint8
- type rune = uint32

类型转换中容易造成歧义，需要使用括号消除歧义，或使阅读更加清晰。如：

```
(*int)(p) 转换为指针。但*int(p) 即为*(int(p))，意为取地址p处的值，这种用法在操作系统管理内存时多用。
```

（4）自定义类型

- type color uint8

自定义类型不是别名。它是从现有的类型定义出一个新的类型，它们已是两种类型，只是拥有相同的底层数据结构。
其区别有以下几点：

- 不拥有原类型的“method set”，即不实现原类型已实现的接口
- 同原类型必须显式转换
- 同原类型不能直接比较

（5）未命名类型

array、slice、map、channel因为与其元素具体类型或长度有关，所以不能给出唯一的名称，固成为未命名类型。

像数组\[2\]int即是，但我们也可以给他取一个名称。

```
type data [2]int
```

未命名类型转换为有名类型的规则如下：

- 所属的类型相同
- 基础类型相同，其中一个是未命名类型。
- 数据类型相同，将双向通道赋值给单向通道，其中一个为未命名类型。
- 将默认值赋值给slice、map、channel、指针、函数或接口。
- 将对象赋值给接口变量，只要对象实现了该接口。


（6）默认值

当申明一个变量时，系统都被默认初始化，以确保不会发生异常。这不同于C的局部变量。

其总结如下：

- false：bool
- 0：int族、uintptr
- 0.0：float族
- 空字符串""：string
- nil：function、interface、slice、map、channel

array、struct根据其元素不同而对应赋予默认值。

（7）类型推断

类型推断就是不用申明具体的类型，而根据被赋予的值推断类型。
所以我们在使用类型推断时，应该清楚的知道当前被赋予什么类型。


```
var1 := 0
var2 := 0.0
// var3 := 0xffffffffffffffff //constant 18446744073709551615 overflows int
fmt.Printf("0: %T\n", var1)
fmt.Printf("0.0: %T\n", var2)

output:
0: int
0.0: float64
```

可以看出整数是推断出int，浮点数是推断出float64，如果超出其范围，在编译时就会报错。


