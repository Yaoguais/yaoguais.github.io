<!DOCTYPE html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>iOS和Android使用MQTT协议实现消息推送和即时通讯</title>
	<link rel="stylesheet" type="text/css" href="/css/style.css" />
    <script type="text/javascript" src="/js/jquery-1.11.2.min.js"></script>
    <link rel="stylesheet" type="text/css" href="/css/markdown.css" />
	<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?">
</head>
<body>
<div class="main-body">
    <div class="left-content" id="markDownContent">
		<div class="mdBlock">
			<h2>iOS和Android使用MQTT协议实现消息推送和即时通讯</h2>
<p>目录:</p>
<ul>
<li>安装配置mosca</li>
<li>安装配置emqtt</li>
<li>配置mosca和emqtt的ssl连接</li>
<li>iOS集成mqtt</li>
<li>Android结成mqtt</li>
</ul>
<h3>安装配置mosca</h3>
<p>因为mosca是nodejs写的应用,所以需要先安装nodejs,安装最新的nodejs只需要两步.</p>
<pre><code># curl --silent --location https://rpm.nodesource.com/setup_4.x | bash -
# yum -y install nodejs</code></pre>
<p>然后创建mosca项目</p>
<pre><code># mkdir mosca
# cd mosca
# npm install mosca --save
# mkdir bin
# cp node_modules/mosca/examples/Server_Wtih_All\ Interfaces-Settings.js bin/server.js
# cp -R node_modules/mosca/test/secure ./</code></pre>
<p>然后我们需要在本地启动redis服务,这里安装启动省略了.
接着我们编辑bin/server.js.</p>
<pre><code>var mosca = require('mosca');

var pubsubSettings = {
  type: 'redis',
  db: 12,
  port: 6379,
  return_buffers: true,
  host: "localhost"
};

var SECURE_KEY = __dirname + '/../secure/tls-key.pem';
var SECURE_CERT = __dirname + '/../secure/tls-cert.pem';

var moscaSetting = {
    interfaces: [
        { type: "mqtt", port: 1883 },
        { type: "mqtts", port: 8883, credentials: { keyPath: SECURE_KEY, certPath: SECURE_CERT } }
        { type: "http", port: 3000, bundle: true },
        { type: "https", port: 3001, bundle: true, credentials: { keyPath: SECURE_KEY, certPath: SECURE_CERT } }
    ],
    stats: false,

    logger: { name: 'MoscaServer', level: 'debug' },

    persistence: { factory: mosca.persistence.Redis, url: 'localhost:6379', ttl: { subscriptions: 1000 * 60 * 10, packets: 1000 * 60 * 10 } },

    backend: pubsubSettings,
};

var authenticate = function (client, username, password, callback) {
    if (username == "test" &amp;&amp; password.toString() == "test")
        callback(null, true);
    else
        callback(null, false);
}

var authorizePublish = function (client, topic, payload, callback) {
    callback(null, true);
}

var authorizeSubscribe = function (client, topic, callback) {
    callback(null, true);
}

var server = new mosca.Server(moscaSetting);

server.on('ready', setup);

function setup() {
    server.authenticate = authenticate;
    server.authorizePublish = authorizePublish;
    server.authorizeSubscribe = authorizeSubscribe;

    console.log('Mosca server is up and running.');
}

server.on("error", function (err) {
    console.log(err);
});

server.on('clientConnected', function (client) {
    console.log('Client Connected \t:= ', client.id);
});

server.on('published', function (packet, client) {
    console.log("Published :=", packet);
});

server.on('subscribed', function (topic, client) {
    console.log("Subscribed :=", client.packet);
});

server.on('unsubscribed', function (topic, client) {
    console.log('unsubscribed := ', topic);
});

server.on('clientDisconnecting', function (client) {
    console.log('clientDisconnecting := ', client.id);
});

server.on('clientDisconnected', function (client) {
    console.log('Client Disconnected     := ', client.id);
});</code></pre>
<p>最后我们启动mosca服务器</p>
<pre><code># node bin/server.js
output:
{"pid":693,"hostname":"devel","name":"MoscaServer","level":30,"time":1472108228321,"msg":"server started","mqtt":1883,"mqtts":8883,"v":1}
Mosca server is up and running.</code></pre>
<p>但是目前我们还不能向mosca发送数据,因为mosca是服务器,而我们还需要一个客户端.
客户端的选择有很多,因为我们这里还要安装emqtt,所以我们就使用emqtt_benchmark带的客户端来测试.</p>
<h3>安装配置emqtt</h3>
<p>emqtt是erlang写的应用,首先我们还是先安装erlang环境.</p>
<pre><code># rpm -i https://packages.erlang-solutions.com/erlang/esl-erlang/FLAVOUR_1_general/esl-erlang_19.0~centos~6_i386.rpm</code></pre>
<p>然后安装emqtt
注: 任何erlang的项目全路径里面带中文会导致项目编译不过,谁带谁SB.</p>
<pre><code># git clone https://github.com/emqtt/emqttd.git
# cd emqttd &amp;&amp; make &amp;&amp; make dist
# cd rel/emqttd &amp;&amp; ./bin/emqttd console</code></pre>
<p>然后安装emqtt_benchmark</p>
<pre><code># git clone git@github.com:emqtt/emqtt_benchmark.git &amp;&amp; cd emqtt_benchmark &amp;&amp; make</code></pre>
<p>然后先使用emqtt_benchmark的pub/sub工具测试emqtt.</p>
<p>emqtt_benchmark:</p>
<pre><code># ./emqtt_bench_sub -h 127.0.0.1 -p 1883 -c 2 -t bench_mark -q 1 -u test -P test -C
# ./emqtt_bench_pub -h 127.0.0.1 -p 1883 -c 2 -u test -P test -t bench_mark -s 10 -q 1</code></pre>
<p>然后我们再使用mosquitto测试pub/sub, 首先安装yum源.</p>
<pre><code>[home_oojah_mqtt]
name=mqtt (CentOS_CentOS-6)
type=rpm-md
baseurl=http://download.opensuse.org/repositories/home:/oojah:/mqtt/CentOS_CentOS-6/
gpgcheck=1
gpgkey=http://download.opensuse.org/repositories/home:/oojah:/mqtt/CentOS_CentOS-6//repodata/repomd.xml.key
enabled=1</code></pre>
<p>安装客户端工具:</p>
<pre><code># yum -y install mosquitto-clients</code></pre>
<p>发布订阅测试:</p>
<pre><code># mosquitto_sub -R -h 127.0.0.1 -p 1883 -c -i client_id_test_10007 -t user/10007 -u mqtt -P my_password -d -q 1
# mosquitto_pub -d -h 127.0.0.1 -p 1883 -i app_service -t user/10007 -m "test" -u mqtt -P my_password -q 1</code></pre>
<p>测试完成,接下来我们再部署基于ssl的连接.</p>
<h3>配置mosca和emqtt的ssl连接</h3>
<p>首先我们使用新版本的ssl生成脚本生成jegarn.com的ssl证书.</p>
<p><a href="https://github.com/Yaoguais/cabin/blob/master/config/salt/salt1_file_system/srv/salt/dev/source/scripts/ssl.sh">脚本下载地址</a></p>
<p>然后修改mosca的server.js文件, 替换成下面的部分:</p>
<pre><code>var SECURE_KEY = '/tmp/ssl/server/server.key';
var SECURE_CERT = '/tmp/ssl/server/server.crt';
var SECURE_CA_CERT = '/tmp/ssl/root/ca.crt';

var moscaSetting = {
    interfaces: [
        { type: "mqtt", port: 1883 },
        { type: "mqtts", port: 8883, credentials: { keyPath: SECURE_KEY, certPath: SECURE_CERT, caPaths: [SECURE_CA_CERT] } },
        { type: "http", port: 3000, bundle: true },
        { type: "https", port: 3001, bundle: true, credentials: { keyPath: SECURE_KEY, certPath: SECURE_CERT } }
    ],
    stats: false,

    logger: { name: 'MoscaServer', level: 'debug' },

    persistence: { factory: mosca.persistence.Redis, url: 'localhost:6379', ttl: { subscriptions: 1000 * 60 * 10, packets: 1000 * 60 * 10 } },

    backend: pubsubSettings,
};</code></pre>
<p>然后我们使用mosquitto的工具测试:</p>
<pre><code># mosquitto_sub -R -h jegarn.com -p 8883 -c -i client_id_test_10008 -t user/10007 -u mqtt -P my_password -d -q 1 --cert client/client.crt --key client/client.key --cafile root/ca.crt
# mosquitto_pub -d -h jegarn.com -p 8883 -i app_service -t user/10007 -m "test" -u mqtt -P my_password -q 1  --cert client/client.crt --key client/client.key --cafile root/ca.crt</code></pre>
<p>经测试订阅端可以正常收到消息,并且mosca也有正确的调试输出.</p>
<p>然后我们接着测试emqtt的ssl连接:</p>
<p>修改emqtt的配置文件&quot;emqttd/rel/emqttd/etc/emqttd.config&quot;,将证书路径替换.</p>
<pre><code>{mqtts, 8883, [
    %% Size of acceptor pool
    {acceptors, 4},

    %% Maximum number of concurrent clients
    {max_clients, 512},

    %% Socket Access Control
    {access, [{allow, all}]},

    %% SSL certificate and key files
    {ssl, [{certfile, "/tmp/ssl/server/server.crt"},
           {keyfile,  "/tmp/ssl/server/server.key"},
           {cacertfile, "/tmp/ssl/root/ca.crt"}]},

    %% Socket Options
    {sockopts, [
        {backlog, 1024}
        %{buffer, 4096},
    ]}
]},</code></pre>
<p>同样我们使用mosquitto的工具测试:</p>
<pre><code># mosquitto_sub -R -h jegarn.com -p 8883 -c -i client_id_test_10008 -t user/10007 -u mqtt -P my_password -d -q 1 --cert client/client.crt --key client/client.key --cafile root/ca.crt
# mosquitto_pub -d -h jegarn.com -p 8883 -i app_service -t user/10007 -m "test" -u mqtt -P my_password -q 1  --cert client/client.crt --key client/client.key --cafile root/ca.crt</code></pre>
<p>经测试订阅端可以正常收到消息.</p>
<p>至此,mosca和emqtt的ssl都正确配置完成,接下来我们完成iOS和Android的SDK接入.</p>
<h3>iOS集成mqtt</h3>
<p>iOS端我们使用<a href="https://github.com/ckrey/MQTT-Client-Framework">MQTTClient库</a>.</p>
<p>这里我们简单实现了连接/订阅/发送消息/接收消息, <a href="https://github.com/Yaoguais/ios-on-the-way/tree/master/mqtt">完成源代码</a>.</p>
<p>如果使用非ssl, 初始化代码如下:</p>
<pre><code>_session = [[MQTTSession alloc] init];
_session.cleanSessionFlag = YES;
_session.delegate = self;
_session.userName = @"test";
_session.password = @"test";

[_session connectToHost:@"jegarn.com" port:1883 usingSSL:NO connectHandler:^(NSError *error) {
    NSLog(@"connect error %@", error);
    // 简单测试订阅/发布
    [self subscribeTest];
    [self publishTest];
}];</code></pre>
<p>ssl连接代码如下:</p>
<pre><code>MQTTSSLSecurityPolicy *securityPolicy = [MQTTSSLSecurityPolicy policyWithPinningMode:MQTTSSLPinningModeCertificate];
NSString *certificate = [[NSBundle bundleForClass:[self class]] pathForResource:@"server" ofType:@"cer"];
securityPolicy.pinnedCertificates = @[[NSData dataWithContentsOfFile:certificate]];
securityPolicy.allowInvalidCertificates = YES;
securityPolicy.validatesCertificateChain = NO;

NSString *p12File = [[NSBundle mainBundle] pathForResource:@"client" ofType:@"p12"];
NSString *p12Password = @"111111";
NSArray * certificates = [MQTTCFSocketTransport clientCertsFromP12:p12File passphrase:p12Password];

_session = [[MQTTSession alloc] init];
_session.cleanSessionFlag = YES;
_session.delegate = self;
_session.userName = @"test";
_session.password = @"test";
_session.securityPolicy = securityPolicy;
_session.certificates = certificates;

[_session connectToHost:@"jegarn.com" port:8883 usingSSL:YES connectHandler:^(NSError *error) {
    NSLog(@"connect error %@", error);
    // 简单测试订阅/发布
    [self subscribeTest];
    [self publishTest];
}];</code></pre>
<p>其中要注意的是在使用SSL的时候,我们一般将validatesCertificateChain设置为NO,因为它会花很长的时间去验证证书链.
而allowInvalidCertificates设置为YES,会在验证系统证书的同时验证我们应用中添加的证书.</p>
<h3>Android结成mqtt</h3>
<p>... 待续</p>
		</div>
    </div>
    <div class="right-nav nav-box">
        <ul class="nav">
			<li><a title="主页导航" href="/index.html">Home</a></li>
            <li><a title="PHP之CLI模式下的执行流程" href="/article/php/cli.html">php cli execute</a></li>
            <li><a title="PHP扩展开发之基础环境及工具介绍" href="/article/php/extension.html">php extension</a></li>
			<li><a title="PHP扩展开发之配置解析" href="/article/php/extension-ini.html">php extension 2</a></li>
			<li><a title="PHP扩展开发之函数与类的实现" href="/article/php/extension-function.html">php extension 3</a></li>
			<li><a title="PHP之编译流程分析" href="/article/php/compile.html">php compile</a></li>
			<li><a title="PHP之PHPNG简介" href="/article/php/php7-intro.html">phpng introduction</a></li>
			<li><a title="PHP之PHPNG实现细节" href="/article/php/php7-vm.html">phpng vm</a></li>
			<li><a title="PHP之把扩展从PHP5升级到PHPNG" href="/article/php/extension-php5to7.html">php5 to phpng</a></li>
			<li><a title="PHP之private修饰符" href="/article/php/php-private.html">php private</a></li>
			<li><a title="xhprof之简介与环境搭建" href="/article/xhprof/intro.html">xhprof intro</a></li>
			<li><a title="xhprof之扩展实现细节" href="/article/xhprof/theory.html">xhprof theory</a></li>
			<li><a title="linux之shell简介" href="/article/linux/shell.html">linux shell</a></li>
			<li><a title="数据结构之最小堆的基本操作" href="/article/data_structure/heap.html">min heap operation</a></li>
			<li><a title="数据结构之二叉搜索树" href="/article/data_structure/binary_search.html">binary search</a></li>
			<li><a title="数据结构之AVL平衡树" href="/article/data_structure/avl.html">avl</a></li>
			<li><a title="数据结构之散列表总结" href="/article/data_structure/hash.html">hash table</a></li>
			<li><a title="MYSQL之索引优化" href="/article/mysql/index.html">mysql index optimize</a></li>
        </ul>
		<div class="back-to-top"></div>
    </div>
</div>
<script type="text/javascript">
	$.nav_high_light = function(obj,on,hlClass){
		hlClass = hlClass || "hover";
		$(".nav li a").removeClass(hlClass);
		if(on){
			$(obj).addClass(hlClass);
		}else{
			var url = $(".mdBlock:visible").attr("data-href");
			$(".nav li a[href='"+url+"']").addClass(hlClass);
		}		
	}
	$.nav_high_light.timeOutHandle = null;
	$(document).ready(function(){
		$(".nav li a").click(function(){
			$.nav_high_light(this,true,"hover");
		}).hover(function(){
			$.nav_high_light(this,true,"hover");
		},function(){
			if($.nav_high_light.timeOutHandle)
				clearTimeout($.nav_high_light.timeOutHandle);
			$.nav_high_light.timeOutHandle = setTimeout(function(){
				$.nav_high_light(this,false,"hover");
			},1000);
		});

		$(".back-to-top").css({
			position : "fixed",
			left : $("#markDownContent").offset().left + $("#markDownContent").width() + 10,
			bottom : "10px"
		}).click(function(){
			$("html,body").stop().animate( { scrollTop: 0}, 200);
		});
		$(window).bind('scroll resize',function(){
			if($("body").scrollTop()>=$(window).height()){
				$(".back-to-top").show();
			}else{
				$(".back-to-top").hide();
			}
		});
		//index-hidden-begin
		$('.mdBlock>ol li').click(function(){
			var index = $(".mdBlock>ol li").index($(this)[0]),
					$title = $(this).parents(".mdBlock").find("h3,h4,h5").eq(index);
			if($title.length>0){
				$("html,body").stop().animate( { scrollTop: $title.offset().top}, 200);
			}
			return false;
		});
		//index-hidden-end
		var $nav = $(".nav");
		$nav.height($("#markDownContent").height() - parseInt($nav.css("margin-top")) - parseInt($nav.css("margin-bottom")));
	});

</script>
</body>
</html>
