<!DOCTYPE html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Golang细节梳理</title>
	<link rel="stylesheet" type="text/css" href="/css/style.css" />
    <script type="text/javascript" src="/js/jquery-1.11.2.min.js"></script>
    <link rel="stylesheet" type="text/css" href="/css/markdown.css" />
	<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?">
</head>
<body>
<div class="main-body">
    <div class="left-content" id="markDownContent">
		<div class="mdBlock">
			<h2>Golang细节梳理</h2>
<p>熟话说，“工欲善其事，必先利其器”。接触Golang也近一年半，多次想梳理一下，都半途而废，这次趁着空闲，刚好可以一一记录下来。</p>
<p>内容多摘自《Go语言学习笔记》，或他人博文，或官方文档。形式为概括与代码结合，阐述也多以代码注释出现。</p>
<p>本篇文档概括至Go最新发布版，且不定更新。主要分三个方面：一是语言特性，如“类型、表达式、函数、数据、方法、接口”等；
二是编程技巧与理念，如“缓存池、用通信实现数据共享”；三是个人理解，如“对开源项目解构”。</p>
<p>目录：</p>
<ol>
<li>类型</li>
<li>常量与变量</li>
<li>表达式</li>
<li>数据</li>
<li>结构体</li>
<li>函数</li>
<li>方法</li>
</ol>
<h3>类型</h3>
<p>类型包含基础类型与引用类型，基础类型包含“int、float”等等，引用类型包含“slice、map、channel”三种类型。</p>
<p>（1）基础类型：</p>
<ul>
<li>1字节的：bool、byte、int8、uint8</li>
<li>2字节的：int16、uint16</li>
<li>4字节的：int32、uint32、rune、float32</li>
<li>8字节的：int64、uint64、float64、complex64</li>
<li>16个字节的：complex128</li>
</ul>
<p>跟32位、64位平台相关的有：</p>
<ul>
<li>4或8字节：int、uint、uintptr</li>
</ul>
<p>额外的基础类型还有：string、array、struct、function、interface。</p>
<p>（2）引用类型：</p>
<ul>
<li>slice</li>
<li>map</li>
<li>channel</li>
</ul>
<p>引用类型有两个特点：</p>
<ol>
<li>作为参数作为返回值时，不发生内存拷贝。因此基础类型array是被发生拷贝的，大数组作为参数应该转换为slice。</li>
<li>使用前应用make进行初始化，用new只会分配返回的指针的内存。如map就不会分配其附加属性count等，也不会正确初始化。</li>
</ol>
<p>（3）类型转换与别名</p>
<p>golang中必须显式类型转换，不同于C/C++。
但是如果是别名的话，因为本身就是同一种类型，因为可以直接赋值。
1.9版本更是增加了定义别名特性。</p>
<p>内置的别名有：</p>
<ul>
<li>type byte = uint8</li>
<li>type rune = uint32</li>
</ul>
<p>类型转换中容易造成歧义，需要使用括号消除歧义，或使阅读更加清晰。如：</p>
<pre><code>(*int)(p) 转换为指针。但*int(p) 即为*(int(p))，意为取地址p处的值，这种用法在操作系统管理内存时多用。</code></pre>
<p>（4）自定义类型</p>
<ul>
<li>type color uint8</li>
</ul>
<p>自定义类型不是别名。它是从现有的类型定义出一个新的类型，它们已是两种类型，只是拥有相同的底层数据结构。
其区别有以下几点：</p>
<ul>
<li>不拥有原类型的“method set”，即不实现原类型已实现的接口</li>
<li>同原类型必须显式转换</li>
<li>同原类型不能直接比较</li>
</ul>
<p>（5）未命名类型</p>
<p>array、slice、map、channel因为与其元素具体类型或长度有关，所以不能给出唯一的名称，固成为未命名类型。</p>
<p>像数组[2]int即是，但我们也可以给他取一个名称。</p>
<pre><code>type data [2]int</code></pre>
<p>未命名类型转换为有名类型的规则如下：</p>
<ul>
<li>所属的类型相同</li>
<li>基础类型相同，其中一个是未命名类型。</li>
<li>数据类型相同，将双向通道赋值给单向通道，其中一个为未命名类型。</li>
<li>将nil赋值给slice、map、channel、指针、函数或接口。</li>
<li>将对象赋值给接口变量，只要对象实现了该接口。</li>
</ul>
<p>（6）默认值</p>
<p>当申明一个变量时，系统都被默认初始化，以确保不会发生异常。这不同于C的局部变量。</p>
<p>其总结如下：</p>
<ul>
<li>false：bool</li>
<li>0：int族、uintptr</li>
<li>0.0：float族</li>
<li>空字符串&quot;&quot;：string</li>
<li>nil：function、interface、slice、map、channel</li>
</ul>
<p>array、struct根据其元素不同而对应赋予默认值。</p>
<p>（7）类型推断</p>
<p>类型推断就是不用申明具体的类型，而根据被赋予的值推断类型。
所以我们在使用类型推断时，应该清楚的知道当前被赋予什么类型。</p>
<pre><code>var1 := 0
var2 := 0.0
// var3 := 0xffffffffffffffff //constant 18446744073709551615 overflows int
var4 := 'c'
var5 := '我'
fmt.Printf("0: %T\n", var1)
fmt.Printf("0.0: %T\n", var2)
// fmt.Printf("0xffffffffffffffff: %T\n", var3)
fmt.Printf("c: %T\n", var4)
fmt.Printf("我: %T\n", var5)

//output:
0: int
0.0: float64
c: int32
我: int32</code></pre>
<p>可以看出整数是推断出int，浮点数是推断出float64，字符是推断出int32，如果超出其范围，在编译时就会报错。</p>
<h3>常量与变量</h3>
<p>（1）常量</p>
<p>常量固不能改变的量。其值必须是编译时期可以确定的字符、字符串、数字或布尔值。</p>
<p>其有以下几个特点：</p>
<ul>
<li>其值必须是字符、字符串、数字、布尔值</li>
<li>支持类型推断</li>
</ul>
<p>在申明时，可以使用常量组，如果不指定类型和初始值，则与上一行非空常量右值表达式文本相同。
这里提到表达式文本，主要是针对iota而言的，因为处于不同行的iota的值是不相同的。</p>
<p>常量的值也可以是编译时期可以确定的表达式，其例子如下：</p>
<pre><code>const (
    ptrSize = unsafe.Sizeof(uintptr(0))
    strSize = len("string")
    sliceCap = cap(sliceA)
)</code></pre>
<ul>
<li>常量也可以在不同作用域定义同名的常量而不会冲突。</li>
</ul>
<p>（2）枚举</p>
<p>在Golang中没有内置枚举类型，但是我们一般是通过常量配合iota实现的。</p>
<p>iota有如下几个特点：</p>
<ul>
<li>作用于常量组，不同常量组的iota的初始值都是0</li>
<li>常量组每增加一行，不管是否包含iota，iota的值都自增1</li>
<li>处于同一行的iota，其值也是相同的</li>
<li>iota的默认类型的int，也可显示指定为其他类型，如float32等</li>
</ul>
<p>（3）变量</p>
<p>变量使用var关键字定义，如果未给初始值系统会初始化为默认值。</p>
<p>变量支持简短模式，即使用操作符“:=”，其有以下三个限制：</p>
<ul>
<li>定义变量需要同时显示初始化</li>
<li>不能申明其数据类型</li>
<li>只能用在函数内部，即不能作用于全局变量</li>
</ul>
<p>变量支持退化赋值，其条件为：至少有一个新变量被定义，新变量须与旧变量处于统一作用域。</p>
<p>局部变量未使用会在编译时报错。但全局变量和常量不会有这个问题。</p>
<p>（4）多变量赋值</p>
<p>赋值时先从左至右依次计算右值，然后再依次赋值给左边的变量。</p>
<p>如下面这种情况：</p>
<pre><code>func inc(x *int, name string) int {
        fmt.Printf("%s: %d\n", name, *x)
        *x++
        return *x
}

func main() {
        x, y := 1, 3
        x, y = inc(&amp;y, "y"), inc(&amp;x, "x")
        fmt.Printf("x=%d, y=%d\n", x, y)
}

// output:
y: 3
x: 1
x=4, y=2</code></pre>
<p>（5）空标识符“_”</p>
<p>空标识符多用在接收多返回值时，忽略其中几个返回值。当然忽略error不是一个好习惯。</p>
<p>另一个常用的地方是检测某类型是否实现目标接口。如：</p>
<pre><code>var _ InterfaceA = new(StructA)</code></pre>
<p>（6）作用域</p>
<p>变量需要特别关注作用域，当多个同名变量出现时，一定要清楚改变的谁，谁又不变。</p>
<p>如下：</p>
<pre><code>var x int
for x, y := 1, 1; x &lt; 5; x, y = x+1, y+1 {
        fmt.Printf("%d ", x)
}
fmt.Printf("\nx=%d\n", x)
// output:
1 2 3 4
x=0

注意，Golang中没有逗号表达式，即不能使用“i++, j++”这样的语句。
解决办法就是前面提到的多变量赋值。</code></pre>
<h3>表达式</h3>
<p>表达式这部分包含八部分：保留字、运算符、优先级、位运算符、二元运算符、自增、指针运算、控制流。</p>
<p>（1）保留字</p>
<p>如果你还不清楚一种语言的任何一个保留字，那么说明你还没有彻底理解这种语言。</p>
<p>Golang目前的保留字有25个，我们如下分类：</p>
<ul>
<li>用作定义的：const、var、type、struct、interface、map、chan、func</li>
<li>用作包管理的：package、import</li>
<li>用作控制流的：if、else、switch、case、for、goto、continue、break、fallthrough、default、select</li>
<li>特殊的：go、defer、range、return</li>
</ul>
<p>除上面这些保留字外，还有一些特殊的关键字，如len、cap。</p>
<p>（2）运算符</p>
<p>运算符除了加减乘除和各种括号外，一个比较的特别的是“&amp;^”，我们叫它“位清除符”，
它将左右操作数都为1的位清除为0。</p>
<p>（3）指针运算</p>
<p>Golang中与指针相关的有取址运算符“&amp;”、指针运算符“*”、类型uintptr、类型unsafe.Pointer。</p>
<p>指针可以支持相等运算符，但不能像C语言一样加减乘除和一般类型转换。</p>
<p>其拥有以下几种特殊操作：</p>
<ul>
<li>任意类型的指针可以被转换成一个 Pointer对象。</li>
<li>相反一个Pointer也可以转换成任意类型的指针。</li>
<li>一个uintptr可以转换成一个Pointer。</li>
<li>相反一个Pointer可以转换成uintptr。</li>
<li>内建的new函数可以为类型T创建零值的对象,它返回的对象类型为*T。</li>
</ul>
<p>unsafe.Pointer定义如下：</p>
<pre><code>type ArbitraryType int  // shorthand for an arbitrary Go type; it is not a real type
type Pointer *ArbitraryType</code></pre>
<p>示例代码如下：</p>
<pre><code>// 移动指针
{
        x := [...]int{1, 2, 3, 4, 5}
        p := &amp;x[0]
        //p = p + 1
        index2Pointer := unsafe.Pointer(uintptr(unsafe.Pointer(p)) + unsafe.Sizeof(x[0]))
        p = (*int)(index2Pointer) //x[1]
        fmt.Printf("%d\n", *p)    //2
}
// 任意类型的指针可以被转换成一个 Pointer对象
// *T -&gt; Pointer to T2
{
        var i int64 = 100
        var p *int64 = &amp;i //*int64
        P := unsafe.Pointer(p)
        fmt.Printf("%T\n", P)
}
// 相反一个Pointer也可以转换成任意类型的指针
// Pointer to T2 -&gt; *T
{
        var i int64 = 100
        var p *int64 = &amp;i //*int64
        P := unsafe.Pointer(p)
        p2 := (*int32)(P) //*int32
        fmt.Println(*p2)
}
// 一个uintptr可以转换成一个Pointer，相反一个Pointer可以转换成uintptr
{
        var i int64 = 200&lt;&lt;32 + 100
        var p = &amp;i
        P0 := unsafe.Pointer(p)
        P := unsafe.Pointer(uintptr(P0) + 4)
        p2 := (*int32)(P)
        fmt.Println(*p2) //200
}
// 内建的new函数可以为类型T创建零值的对象,它返回的对象类型为*T
{
        var i = new(int)
        var s = new(string)
        var j = new(struct{ int })
        fmt.Printf("%T %T %T\n", i, s, j) //*int *string *struct { int }
}
// output:
2
unsafe.Pointer
100
200
*int *string *struct { int }</code></pre>
<p>参考：</p>
<p><a href="http://colobu.com/2016/06/16/dive-into-go-3/"><a href="http://colobu.com/2016/06/16/dive-into-go-3/">http://colobu.com/2016/06/16/dive-into-go-3/</a></a></p>
<p>（4）控制流</p>
<p>Golang用作控制流的保留字，已经在上面例举出来。</p>
<p>控制流也要特别关注变量的作用域，像上面已经列举的for语句，除外还有if、else、switch、select。</p>
<p>这里要提到goto，遇到很多人见到goto就一棒子打死，结果本来goto写出来很干净的代码，非要层层判断导致既冗余又难读，何必呢？</p>
<p>（5）switch</p>
<p>switch在golang中比较特殊，我们单独阐述。其基本结构如下：</p>
<pre><code>switch 条件表达式 {
    case 比较表达式: 语句
    case 比较表达式2: 语句
    default: 语句
}</code></pre>
<p>其有如下特点：</p>
<ul>
<li>条件表达式可以为空，这时其值为true。</li>
<li>条件表达式支持初始化语句，如switch x := 5; x {}。</li>
<li>比较表达式可以有多个值，如case 5, 6，用逗号隔开即可。</li>
<li>每一个比较表达式的语句，最后会自动break。要继续执行紧挨着的下个case或default，需要使用fallthrough。</li>
<li>匹配规则是从上向下，从左向右。从左向右是因为比较表达式支持多个值。</li>
<li>比较表达式可以是布尔值、常量、变量、或逻辑表达式，或多个用逗号隔开的组合。</li>
<li>当所有比较表达式都匹配之后，才会执行default，而且不管default是否放到最后，但一般都放最后。</li>
</ul>
<p>（6）select</p>
<p>select多用在选择多个通道，或结合default来尝试读写通道。</p>
<p>其结构与switch类似：</p>
<pre><code>select {
case &lt;-a:
case &lt;-b:
case &lt;-a:
default:
}</code></pre>
<p>当有多个通道选择时，其具有下面的特点：</p>
<ul>
<li>它会随机选择一个可用的通道，即便是同一通道。</li>
<li>若将通道设置成nil, 则通道便不会被选中。</li>
<li>当所有通道都不可用时，才会执行default的语句。如果没有default，那么select会一直等待通道可用。</li>
<li>关闭通道后，通道会一直可读，但是读出来的是nil。要避免select空跑。</li>
</ul>
<p>（7）break</p>
<p>break用作跳出for、switch或select。</p>
<p>一个特殊用法是结合标签跳出多层循环，如：</p>
<pre><code>func main() {
Exit:
        // fmt.Println("generate invalid break label")
        for i := 0; i &lt; 5; i++ {
                for j := 0; j &lt; 5; j++ {
                        fmt.Println(i, j)
                        if i+j &gt;= 4 {
                                break Exit
                        }
                }
        }
        fmt.Println("end")
}
// output:
0 0
0 1
0 2
0 3
0 4
end</code></pre>
<p>（8）for...range</p>
<p>for...range主要完成迭代，支持字符串、数组、数组指针、切片、字典、通道。</p>
<p>在遍历时的局部变量，也会被重复使用，因而其地址不变。</p>
<p>示例代码如下：</p>
<pre><code>func main() {
        fmt.Println("普通字符串")
        for i, v := range "abc" {
                fmt.Printf("i=%v, v=%v\n", i, v)
        }
        fmt.Println("汉字字符串")
        for i, v := range "汉字" {
                fmt.Printf("i=%v, v=%v\n", i, v)
        }
        fmt.Println("数组")
        for i, v := range [2]int{10, 11} {
                fmt.Printf("i=%v, v=%v\n", i, v)
        }
        for i := range [2]int{10, 11} {
                fmt.Printf("i=%v\n", i)
        }
        fmt.Println("切片")
        for i, v := range []int{10, 11} {
                fmt.Printf("i=%v, v=%v\n", i, v)
        }
        fmt.Println("字典")
        m := make(map[string]string)
        m["a"] = "b"
        for k, v := range m {
                fmt.Printf("k=%v, v=%v\n", k, v)
        }
        for k := range m {
                fmt.Printf("k=%v\n", k)
        }
        fmt.Println("通道")
        c := make(chan int)
        go func() {
                for v := range c {
                        fmt.Printf("v=%v\n", v)
                }
                fmt.Println("read channel finish")
        }()
        c &lt;- 20
        c &lt;- 21
        close(c)
        // c = nil // 会导致for-range阻塞，从而可能导致死锁。
        fmt.Println("局部变量会重复使用")
        for i, v := range [2]int{10, 11} {
                fmt.Printf("i=%v, v=%v\n", &amp;i, &amp;v)
        }

        done := make(chan struct{})
        &lt;-done
}
// output:
普通字符串
i=0, v=97
i=1, v=98
i=2, v=99
汉字字符串
i=0, v=27721
i=3, v=23383
数组
i=0, v=10
i=1, v=11
i=0
i=1
切片
i=0, v=10
i=1, v=11
字典
k=a, v=b
k=a
通道
v=20
局部变量会重复使用
i=0xc420014138, v=0xc420014140
i=0xc420014138, v=0xc420014140
v=21
read channel finish
fatal error: all goroutines are asleep - deadlock!</code></pre>
<p>遍历数组指针，其实就是在遍历其指向的数组。如：</p>
<pre><code>a := [2]int{10, 11}
p := &amp;a
fmt.Printf("%T\n", p)
for i, v := range p {
        fmt.Printf("i=%v, v=%v\n", i, v)
}
// output:
*[2]int
i=0, v=10
i=1, v=11</code></pre>
<p>在遍历数组时，实际遍历的是数组的复制品，所以会发生内存拷贝。可以转换为切片再遍历。
比如：</p>
<pre><code>data := [3]int{10, 20, 30}
for i, x := range data { // 这里有内存拷贝
}
// 不会拷贝内存
for i, x := range data[:] {
}</code></pre>
<h3>数据</h3>
<p>Golang内置的数据类型我们已经在“类型”一章已经梳理。这部分重点讲解string、array、slice、map。
像struct我们单独放一章。</p>
<p>（1）字符串</p>
<p>字符串是不可变字符序列，在golang中的定义类似于[]byte+length。</p>
<p>其有一下特点：</p>
<ul>
<li>不同于C的字符串，结尾没有NULL。而用额外字段length保存内存长度，因而是二进制安全的。</li>
<li>默认以UTF-8存储，但是支持十六进制、八进制、UTF编码，如&quot;\x61\142\u0041&quot;。</li>
<li>可用内置函数len获取长度，但不支持使用cap函数。</li>
<li>默认值是空字符串&quot;&quot;，而不是nil。</li>
<li>可以使用命令提示符“`”，实现跨行字符串。</li>
<li>支持比较符，支持“+、=+”。</li>
<li>支持用下标获取元素，元素类型为uint8，如“str[0]”。</li>
<li>不支持设置元素，如“str[0] = 'A'”会报错。</li>
<li>使用for...range遍历可以获取Unicode字符，比如从字符串“好的”获取“好”出来。可以参考下面代码。</li>
<li>要修改字符串，可以将其转换为[]byte或[]rune，修改后再转换回来。但是一定会重新分配内存。</li>
<li>可用append函数将字符串添加到[]byte中，如“bs = append(bs, &quot;abc&quot;...)”。</li>
<li>拼接多个字符串，可用bytes.Buffer提升性能。</li>
<li>拼接字符串，可以考虑在栈上先分配一个大字节数组，避免垃圾回收，从而提升性能。</li>
<li>标准库“utf8”已提供方法用作判断Unicode字符串是否合法和获取其长度。</li>
</ul>
<p>实现字符串截取：</p>
<pre><code>s := "abcdefg"
s1 := s[:3]
s2 := s[1:4]
s3 := s[2:]
fmt.Printf("%s %s %s\n", s1, s2, s3)
fmt.Printf("%#v\n", (*reflect.StringHeader)(unsafe.Pointer(&amp;s)))
fmt.Printf("%#v\n", (*reflect.StringHeader)(unsafe.Pointer(&amp;s1)))
// s1[0] = 'A'
// fmt.Printf("%s %s %s\n", s1, s2, s3)

// output:
abc bcd cdefg
&amp;reflect.StringHeader{Data:0x4b9008, Len:7}
&amp;reflect.StringHeader{Data:0x4b9008, Len:3}</code></pre>
<p>使用for...range遍历Unicode字符串：</p>
<pre><code>s := "汉字a"
for i := 0; i &lt; len(s); i++ {
        fmt.Printf("%d %c\n", i, s[i])
}
for i, v := range s {
        fmt.Printf("%d %c\n", i, v)
}
// output:
0 æ
1 ±
2 
3 å
4 ­
5 
6 a
0 汉
3 字
6 a</code></pre>
<p>因为字符串和[]byte转换会涉及内存拷贝，可以取巧地使用unsafe.Pointer进行转换而不发生内存拷贝。</p>
<pre><code>package main

import (
        "fmt"
        "reflect"
        "unsafe"
)

func SliceToString(bs []byte) string {
        return *(*string)(unsafe.Pointer(&amp;bs))
}

func StringToSlice(s string) []byte {
        sh := (*reflect.SliceHeader)(unsafe.Pointer(&amp;s))
        sh.Cap = len(s)
        return *(*[]byte)(unsafe.Pointer(sh))
}

func main() {
        bs := []byte("hello")
        arr := [2]byte{'a', 'b'}
        fmt.Println(SliceToString(bs))
        fmt.Println(SliceToString(arr[:]))
        fmt.Printf("%#v\n", StringToSlice("hello"))
}
// output:
hello
ab
[]byte{0x68, 0x65, 0x6c, 0x6c, 0x6f}</code></pre>
<p>（2）数组</p>
<p>数组主要关注其申明和赋值，其常见形式如下：</p>
<pre><code>// 申明
// 申明时，每一纬长度都要明确，要不然就申明成切片了。
var a [2]int
var b [2][2]int
var c [2]int
var d [2][2][2]int
// 初始化
e := [4]int{1, 2}
f := [4]int{10, 3: 13}
g := [...]int{1, 2, 3} // 自动推导长度
h := [...]int{10, 3: 13}
i := [...]int{10, 3: 13, 14}
type user struct {
        name string
}
j := [...]user{
        {"Tom"},
        {name: "Jack"},
}
k := [2]*user{
        &amp;user{"Tom"},
        &amp;user{"Jack"},
}
// 赋值
a = [2]int{1}
b = [2][2]int{1: {1: 1}}

fmt.Println(a, b, c, d, e, f, g, h, i, j, k)</code></pre>
<p>综合来看数组有以下特点：</p>
<ul>
<li>申明时，每一纬长度都要指明。</li>
<li>定义时，只有第一维能使用“...”进行推断。</li>
<li>内置函数len和cap都返回第一维长度</li>
<li>如果元素都支持“==或!=”比较符，那么数组也可以比较，否则会报错。</li>
<li>区别数组指针“<em>[2]int”和指针数组“[2]</em>int”。</li>
<li>数组作为参数或者赋值都会导致内存拷贝，解决办法是转换为切片或者指针。</li>
</ul>
<p>（3）切片</p>
<p>切片是数组的包装。其还有一个指向底层数据的指针，和len、cap两个属性。</p>
<p>其申明和初始化如下：</p>
<pre><code>// 申明
var a []int
var b []int
var c []int
// 初始化
a = make([]int, 0, 5) // len, cap
b = make([]int, 5)    // len, cap默认等于len
c = append(c, 1)
d := []int{10, 3: 13}
// 截取
e := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
f := e[:]
g := e[1:2]
h := e[1:2:6]
i := e[:1:3]
// i := e[1::3] // 语法错误。按1个位置都可以忽略共7种可能，只有这种不行从而有6种可行。
// 其语法含义为[start:end:max]; len = end - start; cap = max - start; cap &gt;= len;
fmt.Println(a, b, c, d)
fmt.Println(e)
fmt.Printf("%#v len:%d cap:%d\n", f, len(f), cap(f))
fmt.Printf("%#v len:%d cap:%d\n", g, len(g), cap(g))
fmt.Printf("%#v len:%d cap:%d\n", h, len(h), cap(h))
fmt.Printf("%#v len:%d cap:%d\n", i, len(i), cap(i))
// output:
[] [0 0 0 0 0] [1] [10 0 0 13]
[0 1 2 3 4 5 6 7 8 9]
[]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} len:10 cap:10
[]int{1} len:1 cap:9
[]int{1} len:1 cap:5
[]int{0} len:1 cap:3</code></pre>
<p>切片还有以下特点：</p>
<ul>
<li>不像数组，它不支持比较操作，仅可判断是否为nil。</li>
<li>
<p>可以使用“s[:]”进行截取。</p>
</li>
<li>支持append函数，append函数从第二个参数开始，都应是切片的元素。</li>
<li>支持copy(起始地址，新增内容)函数。</li>
</ul>
<p>（4）字典</p>
<p>字典即为哈希表。
字典要求key必须能够比较，以便在哈希冲突时解决冲突。
如数字、字符串、指针、某些数组、结构体，某些接口。</p>
<p>其有如下特点：</p>
<ul>
<li>因为是引用类型，需要用make初始化。</li>
<li>获取不存在的key，返回val的默认值。最好使用ok-idiom模式，“v, ok =:= m[&quot;k&quot;]”。</li>
<li>for...range每次遍历，生成的key的序列是不同的。即遍历访问key是随机的。</li>
<li>可以使用len获取元素个数，但不支持cap函数。</li>
<li>字典是非线程安全的，并发读写或删除都会导致错误。</li>
<li>nil字典不可写，但可以读，只是key都是不存在的。</li>
<li>一般为避免重新哈希，需要多少个元素，应创建字典时就指定好。如“m:=make(map[string]string, 1024)”。</li>
<li>字典不会收缩内存，删除大部分key后，可考虑创建新字典以释放内存。</li>
<li>Go1.9新增sync.Map作为线程安全的字典，其性能较高，但因为不是内置类型，使用上需当自定义类型使用。</li>
</ul>
<h3>结构体</h3>
<p>结构体将不同类型的字段组合成一个复合类型。</p>
<p>常见的申明定义初始化如下：</p>
<pre><code>type node struct {
        _    int
        _    int
        val  int
        next *node
}
type user struct {
        name string
        age  byte
}
// u1 := user{"Tom"} // error: too fewer values
u1 := user{"Tom", 16}
u2 := user{name: "Tom"}

u3 := struct {
        name string
        age  byte
}{
        name: "Tom",
        age:  20,
}
type file struct {
        name string
        attr struct {
                owner int
                perm  int
        }
}
f := file{
        name: "a.txt",
        //attr: {
        //  owner: 1,
        //  perm: 0755,
        //},
}
f.attr.owner = 1
f.attr.perm = 0775

type attr struct {
        perm int
}
type File struct {
        name string
        attr
}
f2 := File{
        name: "a.txt",
        attr: attr{
                perm: 0755,
        },
}
f2.perm = 0775

type FILE struct {
        name string
}
type log struct {
        name string
}
type data struct {
        FILE
        log
}
g := data{}
// g.name = "go" // error
g.log.name = "go"
fmt.Println(u1, u2, u3, f, f2, g)</code></pre>
<p>综合上面，结构体具有以下特点：</p>
<ul>
<li>可用“_”作为字段名进行占位，多用于补齐内存布局。</li>
<li>如果结构体只用一次，可以申明为匿名结构体。</li>
<li>空结构struct{}多用在通道，作为通知作用，因为其占内存最小。</li>
<li>结构体支持匿名字段，当匿名字段有属性重名时，需显式读写。</li>
<li>字段标签也是结构的一部分。Go1.9后，只有标签不同的结构体可以相互赋值。</li>
</ul>
<h3>函数</h3>
<p>函数是特定功能的最小单元。Go中使用func定义函数。</p>
<p>（1）定义及特点</p>
<p>其定义如下：</p>
<pre><code>func someFunc(int a, int b) (c int, err error) {
}
带变长参数函数：
func format(s string, a ...interface{}) (string, error){
}</code></pre>
<p>函数具有以下特点：</p>
<ul>
<li>仅能判断函数是否为nil, nil也为函数的默认值。</li>
<li>不支持参数默认值。</li>
<li>在调用变参函数时，可以使用“...”展开切片，如“format(&quot;%d %d&quot;, []interface{}{1, 2}...)”。</li>
<li>支持匿名函数。</li>
<li>通道也可传递函数，包括匿名函数。</li>
<li>支持闭包。</li>
<li>支持延迟调用defer，其顺序是前进后出，构成延迟调用栈。</li>
<li>错误处理中，error多为最后一个返回值。如“func some() (int, error){}”。</li>
<li>没有try/catch，而使用panic/recover。</li>
</ul>
<p>（2）panic/recover</p>
<p>panic会中断函数调用，而执行延迟调用。
而在延迟调用中，可以使用recover捕获panic提交的错误对象。</p>
<p>panic像其他语言一样，一直沿函数调用栈把异常提交到main函数，如果main函数也未捕捉，那么进程奔溃。</p>
<h3>方法</h3>
<p>方法是有名类型绑定的函数。</p>
<p>（1）定义</p>
<p>除内置的“int、string”等外，可以为任何有名类型定义绑定方法。</p>
<p>一般定义如下：</p>
<pre><code>type N int
func (x N) toString() string {
    return fmt.Sprintf("%v", x)
}</code></pre>
<p>（2）匿名字段</p>
<p>可以直接调用结构体中匿名字段的方法。
但是如果结构体也绑定同样的方法，直接调用会调用结构体的方法。若想调用匿名字段的方法，需写清楚字段名，如“f.log.ToString()”。</p>
<p>（3）方法集</p>
<p>类型的方法集，决定其是否实现某一接口。</p>
<p>其有如下规则：</p>
<ul>
<li>类型T方法集包含所有receiver T的方法。</li>
<li>类型<em>T包含所有receiver T + </em>T方法。</li>
<li>匿名嵌入S，T还包含所有receiver S的方法。</li>
<li>匿名嵌入<em>S，T还包含所有receiver S + </em>S方法。</li>
<li>匿名嵌入S或<em>S，</em>T还包含所有receiver S + *S方法。</li>
</ul>
<p>可见，匿名字段即为方法集而精心设计的。</p>
		</div>
    </div>
    <div class="right-nav nav-box">
        <ul class="nav">
			<li><a title="主页导航" href="/index.html">Home</a></li>
            <li><a title="PHP之CLI模式下的执行流程" href="/article/php/cli.html">php cli execute</a></li>
            <li><a title="PHP扩展开发之基础环境及工具介绍" href="/article/php/extension.html">php extension</a></li>
			<li><a title="PHP扩展开发之配置解析" href="/article/php/extension-ini.html">php extension 2</a></li>
			<li><a title="PHP扩展开发之函数与类的实现" href="/article/php/extension-function.html">php extension 3</a></li>
			<li><a title="PHP之编译流程分析" href="/article/php/compile.html">php compile</a></li>
			<li><a title="PHP之PHPNG简介" href="/article/php/php7-intro.html">phpng introduction</a></li>
			<li><a title="PHP之PHPNG实现细节" href="/article/php/php7-vm.html">phpng vm</a></li>
			<li><a title="PHP之把扩展从PHP5升级到PHPNG" href="/article/php/extension-php5to7.html">php5 to phpng</a></li>
			<li><a title="PHP之private修饰符" href="/article/php/php-private.html">php private</a></li>
			<li><a title="xhprof之简介与环境搭建" href="/article/xhprof/intro.html">xhprof intro</a></li>
			<li><a title="xhprof之扩展实现细节" href="/article/xhprof/theory.html">xhprof theory</a></li>
			<li><a title="linux之shell简介" href="/article/linux/shell.html">linux shell</a></li>
			<li><a title="数据结构之最小堆的基本操作" href="/article/data_structure/heap.html">min heap operation</a></li>
			<li><a title="数据结构之二叉搜索树" href="/article/data_structure/binary_search.html">binary search</a></li>
			<li><a title="数据结构之AVL平衡树" href="/article/data_structure/avl.html">avl</a></li>
			<li><a title="数据结构之散列表总结" href="/article/data_structure/hash.html">hash table</a></li>
			<li><a title="MYSQL之索引优化" href="/article/mysql/index.html">mysql index optimize</a></li>
        </ul>
		<div class="back-to-top"></div>
    </div>
</div>
<script type="text/javascript">
	$.nav_high_light = function(obj,on,hlClass){
		hlClass = hlClass || "hover";
		$(".nav li a").removeClass(hlClass);
		if(on){
			$(obj).addClass(hlClass);
		}else{
			var url = $(".mdBlock:visible").attr("data-href");
			$(".nav li a[href='"+url+"']").addClass(hlClass);
		}		
	}
	$.nav_high_light.timeOutHandle = null;
	$(document).ready(function(){
		$(".nav li a").click(function(){
			$.nav_high_light(this,true,"hover");
		}).hover(function(){
			$.nav_high_light(this,true,"hover");
		},function(){
			if($.nav_high_light.timeOutHandle)
				clearTimeout($.nav_high_light.timeOutHandle);
			$.nav_high_light.timeOutHandle = setTimeout(function(){
				$.nav_high_light(this,false,"hover");
			},1000);
		});

		$(".back-to-top").css({
			position : "fixed",
			left : $("#markDownContent").offset().left + $("#markDownContent").width() + 10,
			bottom : "10px"
		}).click(function(){
			$("html,body").stop().animate( { scrollTop: 0}, 200);
		});
		$(window).bind('scroll resize',function(){
			if($("body").scrollTop()>=$(window).height()){
				$(".back-to-top").show();
			}else{
				$(".back-to-top").hide();
			}
		});
		//index-hidden-begin
		$('.mdBlock>ol li').click(function(){
			var index = $(".mdBlock>ol li").index($(this)[0]),
					$title = $(this).parents(".mdBlock").find("h3,h4,h5").eq(index);
			if($title.length>0){
				$("html,body").stop().animate( { scrollTop: $title.offset().top}, 200);
			}
			return false;
		});
		//index-hidden-end
		var $nav = $(".nav");
		$nav.height($("#markDownContent").height() - parseInt($nav.css("margin-top")) - parseInt($nav.css("margin-bottom")));
	});

</script>
</body>
</html>
